# コアロジック

このシステムの中心となる処理ロジックについて説明します。

## 1. LINE Webhook 受信 (`lineWebhook` 関数)

1.  **リクエスト受信:** LINEプラットフォームからHTTP POSTリクエストを受け取ります。
2.  **署名検証:** リクエストヘッダーの `X-Line-Signature` と環境変数に設定されたチャネルシークレットを用いて、リクエストの正当性を検証します (`@line/bot-sdk` を使用)。検証に失敗した場合は、`401 Unauthorized` を返します。
3.  **イベント処理:** リクエストボディ内のイベントを解析します。
    *   **メッセージイベント (テキスト):**
        *   メッセージ内容が `"#登録 <トークン>"` 形式の場合:
            1.  トークンを抽出します。
            2.  イベントソースから `lineUserId` を取得します。
            3.  Firestoreの `mappings` コレクションに `{token: lineUserId}` のドキュメントを作成または上書きします。
            4.  登録完了の応答メッセージをLINEに送信します。
        *   上記以外のテキストメッセージの場合:
            1.  イベントソースから `lineUserId` を取得します。
            2.  Firestoreの `notes/{lineUserId}/items` サブコレクションに新しいドキュメントを作成します。
                *   `content`: メッセージ本文
                *   `created`: Firestoreサーバータイムスタンプ
                *   `synced`: `false`
                *   `tags`: `[]`
            3.  (任意) 受信確認の応答メッセージをLINEに送信します。
    *   **その他のイベント (フォロー、アンフォローなど):** 必要に応じてログ記録などの処理を追加します。
4.  **レスポンス:** LINEプラットフォームに `200 OK` を返します。

## 2. メモ同期 (`syncNotes` 関数)

1.  **リクエスト受信:** ObsidianプラグインからHTTP GETリクエストを受け取ります (`/syncNotes?token=<token>&since=<timestamp>`)。
2.  **認証:** リクエストヘッダーの `Authorization: Bearer <token>` またはクエリパラメータの `token` を検証します。
    *   提供されたトークンが存在しない、または無効な場合は `401 Unauthorized` を返します。
3.  **ユーザー特定:** トークンを使ってFirestoreの `mappings` コレクションを検索し、対応する `lineUserId` を取得します。見つからない場合は `404 Not Found` または `401 Unauthorized` を返します。
4.  **メモ取得:** 取得した `lineUserId` を使用して、`notes/{lineUserId}/items` サブコレクションに対してクエリを実行します。
    *   条件: `synced == false`
    *   `since` パラメータが指定されている場合は、さらに `created > <since>` の条件を追加します。
    *   `created` で昇順にソートします。
5.  **レスポンス:** 取得したメモのリスト（`noteId`, `content`, `created` を含む）をJSON形式で返却します。
6.  **同期後処理 (非同期):** レスポンス送信後、取得対象となったメモドキュメントに対して以下のいずれかの処理を行います（要件定義に基づく）。
    *   `synced` フィールドを `true` に更新する。
    *   ドキュメントを削除する。

## 3. Obsidian プラグイン同期処理

1.  **トリガー:** ユーザーが設定画面の「Sync Now」ボタンをクリック、またはコマンドパレットから「Sync LINE Memos」を実行。
2.  **前回同期時刻取得:** プラグイン設定から `lastSync` の値を取得します。
3.  **APIリクエスト:** 
    * 設定された短縮コードまたは接続IDを使用してAPIエンドポイントを自動構築します。
    * 構築されたエンドポイントと `token` を使用して `syncNotes` APIにGETリクエストを送信します。
    * `since` パラメータには取得した `lastSync` のタイムスタンプを付与します。
4.  **レスポンス処理:** APIから返却されたメモのリスト（JSON）を受け取ります。
5.  **重複チェック:**
    * 同期先フォルダ内の既存ファイルをスキャンし、メモIDからファイルパスのマップを作成します。
    * 同期済みのメモIDリスト(`syncedNoteIds`)を管理して、重複同期を防止します。
6.  **ファイル書き込み:**
    *   取得した各メモについて、メモIDに基づいて既存ファイルの有無を確認します。
    *   既存ファイルがある場合:
        * 既存ファイルを同じ場所で上書き更新します。
    *   既存ファイルがない場合:
        * 設定された `folder` パス配下に新しいMarkdownファイルを作成します。
        * ファイル名: メモの `created` タイムスタンプとメモIDを組み合わせた一意の名前を生成 (例: `YYYYMMDDHHmmssSSS-{id}.md`)。
    *   ファイル内容: メモの `content` を書き込みます。
    *   同期済みIDリストにメモIDを追加します（まだリストにない場合）。
7.  **最終同期時刻更新:** 正常に同期が完了したら、現在のタイムスタンプでプラグイン設定の `lastSync` を更新します。
8.  **同期結果通知:** 新規作成されたファイル数と更新されたファイル数をユーザーに通知します。
9.  **エラーハンドリング:** APIリクエスト失敗時やファイル書き込み失敗時に、ユーザーにエラー通知を表示します。